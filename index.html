<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8" />
    <title>æ‰“å­—è¿é”æ¶ˆé™¤æ¸¸æˆ</title>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            background: #0a0a0a;
            color: white;
            font-family: monospace;
            height: 100vh;
            overflow: hidden;
        }

        #retainedZone {
            display: grid;
            grid-template-columns: repeat(16, 2.6vh);
            justify-content: center;
            gap: 2vh;
            position: absolute;
            top: 15vh;
            left: 50%;
            transform: translateX(-50%);
            padding: 3vh;
            background: rgba(255, 255, 255, 0.04);
            overflow-y: scroll;
            height: 70vh;
            overflow: hidden;
        }

        #retainedZone span {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3.5vh;
            height: 4vh;
            width: 4vh;
            background: rgba(255, 170, 100, 0.2);
            color: #ffbb88;
            border-radius: 1vh;
            transition: all 0.3s ease;
        }

        #retainedZone span:hover {
            background: rgba(100, 255, 180, 0.15);
            box-shadow: 0 0 0.5vh #39ff14;
            transform: scale(1.1);
        }

        .matched-char {
            color: #39ff14;
            background: rgba(0, 0, 0, 0.6);
            text-shadow: 0 0 0.5vh #39ff14;
            transform: scale(0.8);
        }

        .flash-out {
            animation: flashFadeOut 0.6s ease-out forwards;
        }

        @keyframes flashFadeOut {
            0% {
                opacity: 1;
                transform: scale(1);
            }

            50% {
                box-shadow: 0 0 1vh white;
            }

            100% {
                opacity: 0;
                transform: scale(3);
            }
        }

        #input {
            position: absolute;
            bottom: 2vh;
            left: 20vw;
            width: 60vw;
            font-size: 2.2vh;
            background: #1a1a1a;
            padding: 1vh;
            border: none;
            color: white;
            z-index: 99;
        }

        #scoreBoard,
        #comboCounter {
            position: absolute;
            top: 42vh;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            font-size: 5vh;
            pointer-events: none;
        }

        #comboCounter {
            top: 36vh;
            font-size: 3vh;
            color: #ffdf99;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .combo-active {
            opacity: 1 !important;
            animation: pulse 0.3s ease;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.2);
            }

            100% {
                transform: scale(1);
            }
        }

        /* ğŸŒ¬ï¸ æ§åˆ¶æ¡æ ·å¼ */
        #scrollControl {
            position: fixed;
            right: 3vh;
            top: 10vh;
            width: 1.2vh;
            height: 70vh;
            background: rgba(255, 255, 255, 0.04);
            border-radius: 1vh;
            overflow: hidden;
            z-index: 10;
        }

        #scrollThumb {
            position: absolute;
            top: 0;
            height: 10%;
            width: 100%;
            background: linear-gradient(to bottom, #39ff14, #1abc9c);
            border-radius: 1vh;
            animation: breathe 2.2s ease-in-out infinite;
        }

        @keyframes breathe {

            0%,
            100% {
                box-shadow: 0 0 0.3vh #39ff14;
            }

            50% {
                box-shadow: 0 0 1.2vh #39ff14;
            }
        }

        input.matching {
            background-color: #e3fbe3;
            color: #2a8a2a;
            transition: background-color 0.5s ease;
        }

        .fade-in {
            opacity: 0;
            transition: opacity 1s ease-in;
        }

        .fade-in.show {
            opacity: 1;
        }

        .skipped-char {
            opacity: 0.3;
            color: gray;
            text-decoration: line-through;
        }

        #fileInput {
            position: absolute;
            left: 5vh;
            top: 5vh;
            z-index: 99;
        }

        #scoreBoard {
            color: darkgray;
            font-weight: bold;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 10vh;
            opacity: 0.5;
        }

        #comboCounter {
            color: rgb(1, 255, 255);
            font-weight: bold;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 5vh;

        }

        #completionNotice {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 10vh;
            font-weight: bold;
            color: #222;
            /* å¯æ ¹æ®èƒŒæ™¯è°ƒæ•´é¢œè‰² */
            background: rgba(255, 255, 255, 0.9);
            /* åŠé€æ˜èƒŒæ™¯å¯é€‰ */
            padding: 1em 2em;
            border-radius: 2vh;
            z-index: 9999;
            text-align: center;
            display: none;
            opacity: 0;
            transition: opacity 0.6s ease;
        }

        #completionNotice.show {
            opacity: 1;
        }

        #fileList {
            position: absolute;
            background: rgba(255, 255, 255, 0.04);
            padding: 3vh;
            border-radius: 1vh;
            max-height: 90vh;
            position: fixed;
            left: 5vh;
            top: 10vh;
            width: 8vh;
        }

        #fileList button {
            display: block;
            width: 100%;
            margin-bottom: 2vh;
            /* ğŸ‘‰ æŒ‰é’®ä¹‹é—´çš„è·ç¦» */
            padding: 2vh 0;
            background-color: #333;
            /* ğŸ‘‰ æŒ‰é’®èƒŒæ™¯é¢œè‰² */
            color: #39ff14;
            /* ğŸ‘‰ æŒ‰é’®æ–‡å­—é¢œè‰² */
            border: none;
            border-radius: 1vh;
            font-size: 2vh;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        #fileList button:hover {
            background-color: #555;
            /* ğŸ‘‰ é¼ æ ‡æ‚¬åœæ—¶å˜è‰² */
        }

        #comboCanvas {
            position: absolute;
            top: 1vh;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.04);
            overflow-y: scroll;
            width: 70vh;
            height: 10vh;
            overflow: hidden;
            margin-top: 10px;
        }

        .ui-buttons {
            position: fixed;
            bottom: 13vh;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 0 2vw;
            z-index: 9999;
            pointer-events: auto;
        }

        .ui-buttons button {
            background-color: rgba(0, 0, 0, 0.5);
            color: #fb7c00;
            border: none;
            padding: 1vh 2vh;
            font-size: 1.5vh;
            border-radius: 0.5vh;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .ui-buttons button:hover {
            background-color: rgba(0, 0, 0, 0.8);
        }
    </style>
</head>

<body>

    <canvas id="comboCanvas"></canvas>

    <div id="retainedZone"></div>
    <div id="scrollControl">
        <div id="scrollThumb"></div>
    </div>
    <input id="input" placeholder="è¾“å…¥å­—â€¦" autocomplete="off" autofocus />
    <div id="comboCounter"></div>
    <div id="scoreBoard">0</div>
    <input type="file" id="fileInput" accept=".txt" />
    <div id="completionNotice" class="fade-in" style="display: none;">
        ğŸ‰ ä»»åŠ¡å®Œæˆï¼
    </div>
    <div id="fileList"></div>

    <script src="txt/similarWordMap.js"></script>
    <script src="txt/similarCharMap.js"></script>
    <script>
        const retainedZone = document.getElementById('retainedZone');
        const input = document.getElementById('input');
        const scoreBoard = document.getElementById('scoreBoard');
        const comboCounter = document.getElementById('comboCounter');
        const scrollControl = document.getElementById("scrollControl");
        const scrollThumb = document.getElementById("scrollThumb");

        let currentStartIndex = 0;

        const map = window.similarCharMap;

        let comboHistory = []; // å‚¨å­˜ combo æ›²çº¿æ•°æ®


        let composing = false;
        let score = 0;
        let combo = 0;
        const maxChars = 150;

        input.addEventListener('compositionstart', () => composing = true);
        input.addEventListener('compositionend', () => { composing = false; handleInput(); });
        input.addEventListener('input', () => { if (!composing) handleInput(); });

        const fileInput = document.getElementById('fileInput');

        const fileNames = ['sample1.txt', 'sample2.txt', 'sample3.txt', 'ä¸ªäººçœŸå®æ”¹ç¼–æ•…äº‹.txt']; // ğŸ” è‡ªè¡Œæ›¿æ¢æˆä½ çš„å®é™…æ–‡ä»¶å

        const fileListDiv = document.getElementById('fileList');

        fileNames.forEach(name => {
            const btn = document.createElement('button');
            btn.textContent = name.replace('.txt', '');
            btn.style.display = 'block';
            btn.style.marginBottom = '6px';
            btn.style.width = '100%';
            btn.addEventListener('click', () => loadTextFile(name));
            fileListDiv.appendChild(btn);
        });

        function loadTextFile(filename) {
            fetch(`txt/${filename}`)
                .then(resp => resp.text())
                .then(text => {
                    const cleaned = toHalfWidth(text)
                        .replace(/[^\u4e00-\u9fa5a-zA-Z0-9\s]/g, '')
                        .split(/\s+/)
                        .flatMap(w => /^[a-zA-Z0-9]+$/.test(w) ? [w] : [...w])
                        .filter(Boolean);
                    wordPool = cleaned;
                    currentStartIndex = 0;
                    retainedZone.innerHTML = '';
                    updateRetainedZone(0);
                    score = 0;
                    combo = 0;
                    comboHistory = [];
                    scoreBoard.textContent = '0';
                    comboCounter.textContent = 'Combo Ã—0';
                    console.log(`âœ… è¯åº“ [${filename}] å·²è½½å…¥ï¼Œå…± ${wordPool.length} ä¸ªå…ƒç´ `);
                });
        }

        function toHalfWidth(str) {
            return str.replace(/[\uFF01-\uFF5E]/g, ch =>
                String.fromCharCode(ch.charCodeAt(0) - 0xFEE0)
            ).replace(/\u3000/g, ' '); // å…¨è§’ç©ºæ ¼â†’åŠè§’ç©ºæ ¼
        }


        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                const text = toHalfWidth(e.target.result);
                wordPool = text
                    .replace(/[^\u4e00-\u9fa5a-zA-Z0-9\s]/g, '')
                    .split(/\s+/)
                    .flatMap(w => /^[a-zA-Z0-9]+$/.test(w) ? [w] : [...w])
                    .filter(Boolean);

                retainedZone.innerHTML = '';
                updateRetainedZone(0); // ğŸ‘ˆ æ˜¾ç¤ºä» 0 å¼€å§‹çš„ 150 ä¸ªå­—ç¬¦

            };
            reader.readAsText(file, 'utf-8');
        });

        function getNextUnmatchedIndex() {
            const spans = retainedZone.querySelectorAll('span');
            return [...spans].findIndex(
                span => !span.classList.contains('matched-char') && !span.classList.contains('skipped-char')
            );
        }

        function handleInput() {
            let typed = input.value;
            if (!typed) return;

            const toRemove = [];

            for (let i = 0; i < typed.length - 1; i++) {
                const bigram = typed.substring(i, i + 2);
                const nextIndex = getNextUnmatchedIndex();
                if (matchRetained(bigram, nextIndex)) {
                    toRemove.push(bigram);
                    typed = typed.slice(0, i) + typed.slice(i + 2);
                    i = -1; // reset loop
                }
            }

            for (const ch of typed) {
                const nextIndex = getNextUnmatchedIndex();
                if (matchRetained(ch, nextIndex)) {
                    toRemove.push(ch);
                }
            }

            if (toRemove.length) {
                setTimeout(() => {
                    let cur = input.value;
                    toRemove.forEach(tok => {
                        cur = cur.replace(tok, '');
                    });
                    input.value = cur;
                }, 10000);
            }
        }

        function isWordMatch(inputWord, targetWord) {
            if (inputWord === targetWord) return true;
            return (
                window.similarWordMap?.[targetWord]?.includes(inputWord) ||
                window.similarWordMap?.[inputWord]?.includes(targetWord)
            );
        }


        function matchRetained(inputText, index) {
            const spans = retainedZone.querySelectorAll('span');
            const span1 = spans[index];
            const span2 = spans[index + 1];
            if (!span1 || span1.classList.contains('matched-char')) return false;

            const char1 = span1.dataset.char || span1.textContent;
            const char2 = span2?.dataset.char || span2?.textContent || '';
            const combined = char1 + char2;

            const isExact = inputText === char1;
            const isCharSimilar = window.similarCharMap?.[char1]?.includes(inputText);
            const isWordSimilar = isWordMatch?.(inputText, char1);
            const isComboWordMatch = isWordMatch?.(inputText, combined);

            // âœ… å­—ç¬¦çº§æˆ–è¯è¯­ä¸€çº§å‘½ä¸­ï¼ˆå•å­—ï¼‰
            if (isExact || isCharSimilar || isWordSimilar) {
                span1.classList.add('matched-char');
                updateScore(isExact ? 10 : 5);
                combo++;
                updateComboDisplay();
                requestAnimationFrame(checkLineBreak);
                return true;
            }

            // âœ… è¿ç»­ä¸¤ä¸ªå­—æ‹¼æˆè¯è¯­æ—¶ï¼Œè§¦å‘è¯è¯­æ¨¡ç³Šå‘½ä¸­ï¼ˆå¦‚â€œèŒ‚ç‰©â€â†â€œè´¸æ˜“â€ï¼‰
            if (isComboWordMatch && span2 && !span2.classList.contains('matched-char')) {
                span1.classList.add('matched-char');
                span2.classList.add('matched-char');
                updateScore(6); // è¯è¯­æ¨¡ç³Šå¾—åˆ†
                combo++;
                updateComboDisplay();
                requestAnimationFrame(checkLineBreak);
                return true;
            }

            // ğŸŒŸ è·³å­—ç­–ç•¥ï¼ˆå•å­—è·³è·ƒï¼‰
            const span3 = spans[index + 2];
            const char3 = span3?.dataset.char || span3?.textContent || '';
            const skipMatch =
                inputText === char2 ||
                window.similarCharMap?.[char2]?.includes(inputText) ||
                isWordMatch?.(inputText, char2);

            if (skipMatch && span2 && !span2.classList.contains('matched-char')) {
                span1.classList.add('skipped-char');
                span2.classList.add('matched-char');
                updateScore(5);
                combo++;
                updateComboDisplay();
                requestAnimationFrame(checkLineBreak);
                return true;
            }

            combo = 0;
            updateComboDisplay();
            return false;
        }
        let isProcessingLineBreak = false; // å…¨å±€å˜é‡
        function checkLineBreak() {
            if (isProcessingLineBreak) return; // âš ï¸ é¿å…é‡å¤è§¦å‘
            const allSpans = [...retainedZone.querySelectorAll('span')];
            const lines = [];

            for (let i = 0; i < allSpans.length; i += 16) {
                lines.push(allSpans.slice(i, i + 16));
            }

            const fullLine = lines.find(line =>
                line.length === 16 && line.every(s =>
                    s.classList.contains('matched-char') || s.classList.contains('skipped-char')
                )
            );
            if (fullLine) {
                isProcessingLineBreak = true; // é”ä½
                fullLine.forEach(span => span.classList.add('flash-out'));

                setTimeout(() => {
                    fullLine.forEach(span => span.remove());

                    updateScore(160 + combo * 20);
                    combo++;
                    updateComboDisplay();
                    const maxStart = Math.max(0, wordPool.length - maxChars);
                    if (currentStartIndex + 16 <= maxStart) {
                        currentStartIndex += 16;
                        updateRetainedZone(currentStartIndex);
                        const percent = currentStartIndex / (wordPool.length - maxChars);
                        setByPercent(percent);
                    } else {

                        appendNextLineToRetainedZone(); // ğŸ‘ˆ åªåœ¨æœ€åä¸€é¡µæ—¶æ‰§è¡Œè¡¥å……
                        const allMatched = [...retainedZone.querySelectorAll('span')]
                            .every(span => span.classList.contains('matched-char') || span.classList.contains('skipped-char'));

                        if (allMatched && finalLineIndex >= wordPool.length) {
                            showCompletionNotice();
                        }
                    }
                    isProcessingLineBreak = false;
                }, 600);

            }
        }

        function showCompletionNotice() {
            const notice = document.getElementById('completionNotice');
            if (notice) {
                notice.style.display = 'block';
                setTimeout(() => notice.classList.add('show'), 500);
                setTimeout(() => {
                    notice.classList.remove('show');
                    setTimeout(() => notice.style.display = 'none', 10000);
                }, 5000);
            }
        }



        function updateScore(value) {
            score += value;
            scoreBoard.textContent = score;
        }

        function updateComboDisplay() {
            if (combo > 0) {
                comboCounter.textContent = `Combo Ã—${combo}`;
                comboCounter.classList.add('combo-active');
                setTimeout(() => comboCounter.classList.remove('combo-active'), 500);
            } else {
                comboCounter.textContent = 'âœ”ï¸';
            }
        }

        let wordPool = [];


        let isDragging = false;

        function updateRetainedZone(startIndex) {
            currentStartIndex = startIndex;

            const chunk = wordPool.slice(startIndex, startIndex + maxChars);

            retainedZone.replaceChildren(
                ...chunk.map(char => {
                    const span = document.createElement('span');
                    span.textContent = char;
                    span.dataset.char = char;
                    return span;
                })
            );

            // ğŸ‘‡ åŠ¨æ€è®¾ç½® finalLineIndexï¼Œæ¯æ¬¡åŠ è½½é¡µé¢æ—¶å‡†ç¡®é‡ç½®
            finalLineIndex = startIndex + chunk.length;
        }


        let finalLineIndex = currentStartIndex;


        function appendNextLineToRetainedZone() {
            if (finalLineIndex >= wordPool.length) return;

            const nextChars = wordPool.slice(
                finalLineIndex,
                Math.min(finalLineIndex + 16, wordPool.length) // âœ… é˜²æ­¢ slice è¶Šç•Œ
            );

            nextChars.forEach(char => {
                const span = document.createElement('span');
                span.textContent = char;
                span.dataset.char = char;
                retainedZone.appendChild(span);
            });

            finalLineIndex += 16; // ğŸ” æ›´æ–°ä¸‹æ¬¡è¿½åŠ èµ·ç‚¹
        }




        // åˆå§‹åŒ–ï¼šè®¾ç½®æ»‘å—é«˜åº¦
        scrollThumb.style.height = `${(maxChars / wordPool.length) * 100}%`;
        setByPercent(0); // é»˜è®¤æ˜¾ç¤ºé¡¶éƒ¨å†…å®¹


        // æ‹–åŠ¨å¼€å§‹
        scrollThumb.addEventListener('mousedown', e => {
            isDragging = true;
            e.preventDefault();
        });
        function setByPercent(percent) {
            percent = Math.max(0, Math.min(percent, 1));
            const offset = percent * (scrollControl.clientHeight - scrollThumb.offsetHeight);
            scrollThumb.style.top = `${offset}px`;

            const startIndex = Math.floor(percent * (wordPool.length - maxChars));
            updateRetainedZone(startIndex);
        }

        // æ‹–åŠ¨ä¸­
        document.addEventListener('mousemove', e => {
            if (!isDragging) return;

            const rect = scrollControl.getBoundingClientRect();
            const offset = e.clientY - rect.top;
            const range = scrollControl.clientHeight - scrollThumb.offsetHeight;
            const percent = Math.max(0, Math.min(offset / range, 1));

            setByPercent(percent);
        });

        // æ‹–åŠ¨ç»“æŸ
        document.addEventListener('mouseup', () => {
            isDragging = false;
        });

        function updateComboDisplay() {
            if (combo > 0) {
                comboCounter.textContent = `Combo Ã—${combo}`;
                comboCounter.classList.add('combo-active');
                comboHistory.push(combo);

                if (comboHistory.length % 2 === 0) {
                    renderComboCanvas(); // ğŸ–Œï¸ æ¸²æŸ“ Canvas å›¾
                }

                setTimeout(() => comboCounter.classList.remove('combo-active'), 500);
            } else {
                comboCounter.textContent = 'Combo Ã—0';
                comboHistory.push(0);

                if (comboHistory.length % 2 === 0) {
                    renderComboCanvas();
                }
            }
        }

        function renderComboCanvas() {
            const canvas = document.getElementById('comboCanvas');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;

            ctx.clearRect(0, 0, w, h); // æ¸…ç©ºç”»å¸ƒ

            const barWidth = 4; // æ¯æ¡æŸ±å­å®½åº¦
            const gap = 1;      // æŸ±å­ä¹‹é—´é—´éš”
            const visibleBars = Math.floor(w / (barWidth + gap));
            const visibleHistory = comboHistory.slice(-visibleBars);
            const maxCombo = Math.max(...visibleHistory, 1); // é˜²æ­¢é™¤ä»¥ 0

            visibleHistory.forEach((value, i) => {
                const barHeight = (value / maxCombo) * h;
                const x = i * (barWidth + gap);
                const y = h - barHeight;

                // ğŸ¨ è‰²å½©æ˜ å°„ï¼šé«˜ combo è¶Šçº¢ï¼Œä½ combo è¶Šè“
                const hue = Math.min(120 + value * 5, 360);
                ctx.fillStyle = `hsl(${hue}, 80%, 60%)`;
                ctx.fillRect(x, y, barWidth, barHeight);
            });
        }
        window.addEventListener('DOMContentLoaded', () => {
            loadTextFile('ä¸ªäººçœŸå®æ”¹ç¼–æ•…äº‹.txt');
        });



    </script>
    <div class="ui-buttons">
        <button id="about-button">aj300</button>
        <button id="fullscreen-button">fullscreen</button>
    </div>

    <script>
        document.getElementById("fullscreen-button").addEventListener("click", () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        });

        document.getElementById("about-button").addEventListener("click", () => {
            window.open("https://aj300542.github.io/", "_blank");
        });
    </script>
</body>

</html>

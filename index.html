<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8" />
    <title>ÊâìÂ≠óËøûÈîÅÊ∂àÈô§Ê∏∏Êàè</title>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            background: #0a0a0a;
            color: white;
            font-family: monospace;
            height: 100vh;
            overflow: hidden;
        }

        #retainedZone {
            display: grid;
            grid-template-columns: repeat(16, 2.6vh);
            justify-content: center;
            gap: 2vh;
            position: absolute;
            top: 5vh;
            left: 50%;
            transform: translateX(-50%);
            padding: 3vh;
            background: rgba(255, 255, 255, 0.04);
            overflow-y: scroll;
            height: 70vh;
            overflow: hidden;
        }

        #retainedZone span {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3.5vh;
            height: 4vh;
            width: 4vh;
            background: rgba(255, 170, 100, 0.2);
            color: #ffbb88;
            border-radius: 1vh;
            transition: all 0.3s ease;
        }

        #retainedZone span:hover {
            background: rgba(100, 255, 180, 0.15);
            box-shadow: 0 0 0.5vh #39ff14;
            transform: scale(1.1);
        }

        .matched-char {
            color: #39ff14;
            background: rgba(0, 0, 0, 0.6);
            text-shadow: 0 0 0.5vh #39ff14;
            transform: scale(0.8);
        }

        .flash-out {
            animation: flashFadeOut 0.6s ease-out forwards;
        }

        @keyframes flashFadeOut {
            0% {
                opacity: 1;
                transform: scale(1);
            }

            50% {
                box-shadow: 0 0 1vh white;
            }

            100% {
                opacity: 0;
                transform: scale(3);
            }
        }

        #input {
            position: absolute;
            bottom: 2vh;
            left: 20vw;
            width: 60vw;
            font-size: 2.2vh;
            background: #1a1a1a;
            padding: 1vh;
            border: none;
            color: white;
        }

        #scoreBoard,
        #comboCounter {
            position: absolute;
            top: 42vh;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            font-size: 5vh;
            pointer-events: none;
        }

        #comboCounter {
            top: 36vh;
            font-size: 3vh;
            color: #ffdf99;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .combo-active {
            opacity: 1 !important;
            animation: pulse 0.3s ease;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.2);
            }

            100% {
                transform: scale(1);
            }
        }

        /* üå¨Ô∏è ÊéßÂà∂Êù°Ê†∑Âºè */
        #scrollControl {
            position: fixed;
            right: 3vh;
            top: 10vh;
            width: 1.2vh;
            height: 70vh;
            background: rgba(255, 255, 255, 0.04);
            border-radius: 1vh;
            overflow: hidden;
            z-index: 10;
        }

        #scrollThumb {
            position: absolute;
            top: 0;
            height: 10%;
            width: 100%;
            background: linear-gradient(to bottom, #39ff14, #1abc9c);
            border-radius: 1vh;
            animation: breathe 2.2s ease-in-out infinite;
        }

        @keyframes breathe {

            0%,
            100% {
                box-shadow: 0 0 0.3vh #39ff14;
            }

            50% {
                box-shadow: 0 0 1.2vh #39ff14;
            }
        }

        input.matching {
            background-color: #e3fbe3;
            color: #2a8a2a;
            transition: background-color 0.5s ease;
        }
    </style>
</head>

<body>
    <div id="retainedZone"></div>
    <div id="scrollControl">
        <div id="scrollThumb"></div>
    </div>
    <input id="input" placeholder="ËæìÂÖ•Â≠ó‚Ä¶" autocomplete="off" autofocus />
    <div id="comboCounter">Combo √ó0</div>
    <div id="scoreBoard">0</div>

    <script>
        const retainedZone = document.getElementById('retainedZone');
        const input = document.getElementById('input');
        const scoreBoard = document.getElementById('scoreBoard');
        const comboCounter = document.getElementById('comboCounter');
        const scrollControl = document.getElementById("scrollControl");
        const scrollThumb = document.getElementById("scrollThumb");

        let currentStartIndex = 0;



        let composing = false;
        let score = 0;
        let combo = 0;
        const maxChars = 150;

        input.addEventListener('compositionstart', () => composing = true);
        input.addEventListener('compositionend', () => { composing = false; handleInput(); });
        input.addEventListener('input', () => { if (!composing) handleInput(); });

        function handleInput() {
            let typed = input.value.trim();
            if (!typed) return;

            const toRemove = [];

            for (const char of typed) {
                if (matchRetained(char)) {
                    toRemove.push(char);
                }
            }

            if (toRemove.length) {
                // ‰øùÁïôÂéüÂßãËæìÂÖ•ÔºåÂª∂Ëøü‰∏§ÁßíÂêéÊ∏ÖÁêÜÂ∑≤ÂåπÈÖçÂ≠óÁ¨¶
                setTimeout(() => {
                    let currentValue = input.value;
                    toRemove.forEach(c => {
                        currentValue = currentValue.replace(c, '');
                    });
                    input.value = currentValue;
                }, 10000);
            }
        }


        function matchRetained(char) {
            const spans = [...retainedZone.querySelectorAll('span')];
            const nextTarget = spans.find(s => !s.classList.contains('matched-char'));

            // Â¶ÇÊûú‰∏ã‰∏Ä‰∏™ÁõÆÊ†áÂàöÂ•ΩÊòØËæìÂÖ•ÁöÑÂ≠óÁ¨¶ÔºåÂàôÂåπÈÖçÊàêÂäü
            if (nextTarget && nextTarget.dataset.char === char) {
                nextTarget.classList.add('matched-char');
                updateScore(10);
                requestAnimationFrame(() => checkLineBreak());
                return true;
            }

            // ÂåπÈÖçÂ§±Ë¥•ÔºåÈáçÁΩÆËøûÂáª
            combo = 0;
            updateComboDisplay();
            return false;
        }


        function checkLineBreak() {
            const allSpans = [...retainedZone.querySelectorAll('span')];
            const lines = [];

            for (let i = 0; i < allSpans.length; i += 16) {
                lines.push(allSpans.slice(i, i + 16));
            }

            const fullLine = lines.find(line =>
                line.length === 16 && line.every(s => s.classList.contains('matched-char'))
            );

            if (fullLine) {
                fullLine.forEach(span => span.classList.add('flash-out'));
                setTimeout(() => {
                    fullLine.forEach(span => span.remove());
                }, 600);

                updateScore(160 + combo * 20);
                combo++;
                updateComboDisplay();

                fillRetainedZone();
            }
        }

        function updateScore(value) {
            score += value;
            scoreBoard.textContent = score;
        }

        function updateComboDisplay() {
            if (combo > 0) {
                comboCounter.textContent = `Combo √ó${combo}`;
                comboCounter.classList.add('combo-active');
                setTimeout(() => comboCounter.classList.remove('combo-active'), 500);
            } else {
                comboCounter.textContent = 'Combo √ó0';
            }
        }

        let wordPool = [];

        fetch('./txt/word.txt')
            .then(res => res.ok ? res.text() : Promise.reject('Âä†ËΩΩÂ§±Ë¥•'))
            .then(text => {
                wordPool = text
                    .replace(/[^\u4e00-\u9fa5a-zA-Z\s]/g, '')
                    .split(/\s+/)
                    .flatMap(w => /^[a-zA-Z]+$/.test(w) ? [w] : [...w])
                    .filter(Boolean);

                fillRetainedZone();
            })
            .catch(err => {
                alert('‚ùå Êó†Ê≥ïÂä†ËΩΩËØçÂ∫ìÊñá‰ª∂Ôºö' + err);
            });

        function fillRetainedZone() {
            while (retainedZone.querySelectorAll('span').length < maxChars && wordPool.length) {
                const char = wordPool.shift();
                const span = document.createElement('span');
                span.textContent = char;
                span.dataset.char = char;
                retainedZone.appendChild(span);
            }
        }

        let isDragging = false;

        function updateRetainedZone(startIndex) {
            currentStartIndex = startIndex;
            retainedZone.innerHTML = '';

            const chunk = wordPool.slice(startIndex, startIndex + maxChars);
            chunk.forEach(char => {
                const span = document.createElement('span');
                span.textContent = char;
                span.dataset.char = char;
                retainedZone.appendChild(span);
            });
        }

        // ÂàùÂßãÂåñÔºöËÆæÁΩÆÊªëÂùóÈ´òÂ∫¶
        scrollThumb.style.height = `${(maxChars / wordPool.length) * 100}%`;
        setByPercent(0); // ÈªòËÆ§ÊòæÁ§∫È°∂ÈÉ®ÂÜÖÂÆπ


        // ÊãñÂä®ÂºÄÂßã
        scrollThumb.addEventListener('mousedown', e => {
            isDragging = true;
            e.preventDefault();
        });
        function setByPercent(percent) {
            percent = Math.max(0, Math.min(percent, 1));
            const offset = percent * (scrollControl.clientHeight - scrollThumb.offsetHeight);
            scrollThumb.style.top = `${offset}px`;

            const startIndex = Math.floor(percent * (wordPool.length - maxChars));
            updateRetainedZone(startIndex);
        }

        // ÊãñÂä®‰∏≠
        document.addEventListener('mousemove', e => {
            if (!isDragging) return;

            const rect = scrollControl.getBoundingClientRect();
            const offset = e.clientY - rect.top;
            const range = scrollControl.clientHeight - scrollThumb.offsetHeight;
            const percent = Math.max(0, Math.min(offset / range, 1));

            setByPercent(percent);
        });

        // ÊãñÂä®ÁªìÊùü
        document.addEventListener('mouseup', () => {
            isDragging = false;
        });



    </script>
</body>

</html>